# H1 — заголовок первого уровня, самый большой
## H2 — заголовок второго уровня, поменьше
### H3
#### H4
##### H5
###### H6 — заголовок шестого уровня, самый маленький

#### Заголовок 4

Текст над чертой

---

Текст под чертой 

Текст до переноса  
Текст после переноса <br>
Текст после второго переноса

line

another line

line 
another line 

Курсив — это *звёздочки* или _подчёркивания_.
Полужирный шрифт — двойные **звёздочки** или двойные __подчёркивания__.
Можно совместить выделение **звёздочки и _подчёркивания_**.
~~Зачёркнутый текст.~~ 

1. Первый пункт нумерованного списка.
2. Второй пункт.

* первый пункт ненумерованного списка;
* второй пункт ненумерованного списка

- первый пункт ненумерованного списка;
- второй пункт ненумерованного списка

[Яндекс](https://www.yandex.ru)
[Яндекс](https://www.yandex.ru "Я Yandex!")

```bash
ls - la
```
```html
<h1>А я просто текст</h1>
```
---

# Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

## Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

## Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```
Это лишь некоторые функции markdown.

---

Настройка Git:

```git config``` --global user.name "ваше имя или ник латиницей" 
```git config``` --global user.email ваша электронная почта

Сделать текущую папку репозиторием:
```git init```

((Разгитить текущую папку - удалить папку ```.git:
rm -rf .git```	))

Узнать состояние репозитория (название ветки, инфа о коммитах):
```git status```

Отслеживать состояние файлов в репозитории (Команда git add не сохраняет содержимое файлов в репозитории,
а отслеживает изменения и подготавливет файлы к коммиту):
```git add```			- конкретного файла
```git add --all```	- всех файлов
```git add .```		- добавить всю текущую папку

Выполнить коммит (сохранить версию):
```git commit -m``` 'Сообщение с информацией об изменениях'	(сообщение лучше писать в инфинитиве: "Исправить", "Добавить")
														(первый коммит принято называть 'Initial commit')

Просмотреть коммиты:
```git log```
```git log --oneline```	- Сокращенный лог

```git remote -v```			- проверка, что локальный и удаленный репозитории связаны

Генерация SSH-ключа:
```cd ~```
```ssh-keygen -t ed25519 -C``` "Почта, к которой привязан Git"
```ls -a ~/.ssh```
^^ в папке C:/Users/user/.ssh созданы два ключа, один публичный - с расширением .pub, а один приватный - без расширений.
Публичным файлом можно делиться с веб-сайтами или коллегами. Приватный ни в коем случае не передавайте никому!

## После создания локального репозитория, стоит загрузить его на GitHub: ##
1. На сайте создать новый репозиторий (не обязательно, но желательно с тем же именем, что и локальный)
2. Привязать публичный SSH-ключ к GitHub:
```clip < ~/.ssh/id_rsa.pub``` (или cat ~/.ssh/'название файла с ключем'.pub)		- скопировать ключ в буфер
Перейдите на GitHub и выберите пункт Settings в меню аккаунта.
В меню слева нажмите на пункт SSH and GPG keys.
В открывшейся вкладке выберите New SSH key
В поле Titleнапишите название ключа. Например, Personal key.
В поле Key type должно быть Authentication Key.
В поле Key скопируйте ваш ключ из буфера обмена.
Нажмите на кнопку Add SSH key
Проверьте правильность ключа с помощью следующей команды:
```ssh -T git@github.com```
3. Зайти в удаленный репозиторий, выбрать тип SSH и скопировать ссылку
Перейти в папку локального репозитория и прописать:
```git remote add origin``` <скопированный url>	- связывает репозитории
```git remote -v```								- проверка, что репозитории связаны
4. Отправить изменения на удаленныый репозиторий:
Первый раз это делается так:
```git push -u origin main```
или
```git push -u origin master```

Файлы отправлены, ветка создана.

Чтобы пушить коммиты теперь достаточно просто:
```git push```

## Полный процесс управления версиями и сохранения текущей версии в удаленный репозиторий выглядит так: ##
```git add --all ```											- подготовка всех файлов к коммиту
```git status	```											- проверка статуса изменений
```git commit -m``` 'Сообщение с информацией об изменениях' 	- коммит (сообщение лучше писать в инфинитиве: "Исправить", "Добавить")
```git push```												- пуш коммитов
```git push -u origin``` 'название ветки'						- пуш определенной ветки

## Работа над ошибками в коммитах:

Делать это лучше ДО git push данного коммита, иначе перезаписать удаленный коммит можно будет только с помощью git push --force,
что может привести к конфликтам, если другие разработчики сделают свои коммиты до ваших изменений:
```git commit --amend --no-edit```							- сделать правки к последнему коммиту без изменения комментария
```git commit --amend -m``` 'Новое сообщение'					- изменить комментарий последнего коммита
```git restore --staged``` <file>								- убрать файл из staged (после ошибочного git add не того файла)
```git reset --hard``` <commit hash>							- откатить изменения проекта до нужного коммита
```git restore``` <file>										- откатить измененный файл до версии последнего коммита

```git diff```									- покажет отличия modified файлов с их последними сохраненными версиями
```git diff --staged```							- покажет отличия staged файлов с их последними сохраненными версиями
```git diff``` <1-хэш> <2-хэш>					- покажет отличия между коммитами с указаными хэшами (как превратить состояние 1 в состояние 2)
```git diff``` <название_ветки1> <название_ветки2>	- покажет отличия между ветками
```git diff HEAD~ HEAD```				- отличия между предыдущим и текущим коммитами
```git diff HEAD~3 HEAD~2```			- отличия между ЧЕТВЁРТЫМ с конца и ТРЕТЬИМ с конца коммитами (нумерация с нуля, HEAD~0 или HEAD - текущий)

```.gitignore```								- файл в корне репозитория, в котором указываются игнорируемые untrecked файлы